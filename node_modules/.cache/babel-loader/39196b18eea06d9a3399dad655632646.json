{"ast":null,"code":"import { isDraft, original, createDraft, finishDraft, setAutoFreeze } from 'immer-peasy';\nimport React, { createContext, useContext, useRef, useReducer, useState, useEffect, useLayoutEffect, useMemo } from 'react';\nimport { compose, createStore as createStore$1, applyMiddleware } from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport memoizerific from 'memoizerific';\nimport isPlainObject from 'is-plain-object';\nimport debounce from 'debounce';\nvar StoreContext = createContext(); // To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    var store = useContext(Context);\n    var mapStateRef = useRef(mapState);\n    var stateRef = useRef();\n    var mountedRef = useRef(true);\n    var subscriptionMapStateError = useRef();\n\n    var _useReducer = useReducer(function (s) {\n      return s + 1;\n    }, 0),\n        forceRender = _useReducer[1];\n\n    if (subscriptionMapStateError.current || mapStateRef.current !== mapState || stateRef.current === undefined) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          var errorMessage = \"An error occurred trying to map state in a useStoreState hook: \" + err.message + \".\";\n\n          if (subscriptionMapStateError.current) {\n            errorMessage += \"\\nThis error may be related to the following error:\\n\" + subscriptionMapStateError.current.stack + \"\\n\\nOriginal stack trace:\";\n          }\n\n          throw new Error(errorMessage);\n        }\n\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(function () {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(function () {\n      var checkMapState = function checkMapState() {\n        try {\n          var newState = mapStateRef.current(store.getState());\n          var isStateEqual = typeof equalityFn === 'function' ? equalityFn(stateRef.current, newState) : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n\n      var unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return function () {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n    return stateRef.current;\n  };\n}\n\nvar useStoreState = createStoreStateHook(StoreContext);\n\nfunction createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    var store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nvar useStoreActions = createStoreActionsHook(StoreContext);\n\nfunction createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    var store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nvar useStoreDispatch = createStoreDispatchHook(StoreContext);\n\nfunction useStore() {\n  return useContext(StoreContext);\n}\n\nfunction createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    var store = useContext(Context);\n\n    var _useState = useState(false),\n        rehydrated = _useState[0],\n        setRehydrated = _useState[1];\n\n    useEffect(function () {\n      store.persist.resolveRehydration().then(function () {\n        return setRehydrated(true);\n      });\n    }, []);\n    return rehydrated;\n  };\n}\n\nvar useStoreRehydrated = createStoreRehydratedHook(StoreContext);\n\nfunction createTypedHooks() {\n  return {\n    useStoreActions: useStoreActions,\n    useStoreDispatch: useStoreDispatch,\n    useStoreState: useStoreState,\n    useStoreRehydrated: useStoreRehydrated,\n    useStore: useStore\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar actionSymbol = 'a';\nvar actionOnSymbol = 'aO';\nvar computedSymbol = 'c';\nvar persistSymbol = 'p';\nvar reducerSymbol = 'r';\nvar thunkOnSymbol = 'tO';\nvar thunkSymbol = 't';\n\nvar debug = function debug(state) {\n  if (isDraft(state)) {\n    return original(state);\n  }\n\n  return state;\n};\n\nvar memo = function memo(fn, cacheSize) {\n  return memoizerific(cacheSize)(fn);\n};\n\nvar actionOn = function actionOn(targetResolver, fn) {\n  fn[actionOnSymbol] = {\n    targetResolver: targetResolver\n  };\n  return fn;\n};\n\nvar action = function action(fn) {\n  fn[actionSymbol] = {};\n  return fn;\n};\n\nvar defaultStateResolvers = [function (state) {\n  return state;\n}];\n\nvar computed = function computed(fnOrStateResolvers, fn) {\n  if (typeof fn === 'function') {\n    fn[computedSymbol] = {\n      stateResolvers: fnOrStateResolvers\n    };\n    return fn;\n  }\n\n  fnOrStateResolvers[computedSymbol] = {\n    stateResolvers: defaultStateResolvers\n  };\n  return fnOrStateResolvers;\n};\n\nvar persist = function persist(model, config) {\n  var _extends2;\n\n  return _extends({}, model, (_extends2 = {}, _extends2[persistSymbol] = config, _extends2));\n};\n\nvar thunkOn = function thunkOn(targetResolver, fn) {\n  fn[thunkOnSymbol] = {\n    targetResolver: targetResolver\n  };\n  return fn;\n};\n\nvar thunk = function thunk(fn) {\n  fn[thunkSymbol] = {};\n  return fn;\n};\n\nvar reducer = function reducer(fn) {\n  fn[reducerSymbol] = {};\n  return fn;\n};\n\nvar deepCloneStateWithoutComputed = function deepCloneStateWithoutComputed(source) {\n  var recursiveClone = function recursiveClone(current) {\n    var next = Object.keys(current).reduce(function (acc, key) {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n\n      return acc;\n    }, {});\n    Object.keys(next).forEach(function (key) {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  };\n\n  return recursiveClone(source);\n};\n\nvar isPromise = function isPromise(x) {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n};\n\nfunction get(path, target) {\n  return path.reduce(function (acc, cur) {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nfunction newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n\n  var newState = _extends({}, currentState);\n\n  var key = currentPath[0];\n\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n\n  return newState;\n}\n\nvar set = function set(path, target, value) {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach(function (key) {\n        delete target[key];\n      });\n      Object.keys(value).forEach(function (key) {\n        target[key] = value[key];\n      });\n    }\n\n    return;\n  }\n\n  path.reduce(function (acc, cur, idx) {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n\n    return acc[cur];\n  }, target);\n};\n\nfunction createSimpleProduce(disableImmer) {\n  if (disableImmer === void 0) {\n    disableImmer = false;\n  }\n\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      var _current = get(path, state);\n\n      var next = fn(_current);\n\n      if (_current !== next) {\n        return newify(path, state, next);\n      }\n\n      return state;\n    }\n\n    if (path.length === 0) {\n      var _draft = createDraft(state);\n\n      var _result = fn(_draft);\n\n      if (_result) {\n        return isDraft(_result) ? finishDraft(_result) : _result;\n      }\n\n      return finishDraft(_draft);\n    }\n\n    var parentPath = path.slice(0, path.length - 1);\n    var draft = createDraft(state);\n    var parent = get(parentPath, state);\n    var current = get(path, draft);\n    var result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n\n    return finishDraft(draft);\n  };\n}\n\nfunction createReducer(disableImmer, actionReducersDict, customReducers, computedProperties) {\n  var simpleProduce = createSimpleProduce(disableImmer);\n\n  var runActionReducerAtPath = function runActionReducerAtPath(state, action, actionReducer, path) {\n    return simpleProduce(path, state, function (draft) {\n      return actionReducer(draft, action.payload);\n    });\n  };\n\n  var reducerForActions = function reducerForActions(state, action) {\n    var actionReducer = actionReducersDict[action.type];\n\n    if (actionReducer) {\n      var actionMeta = actionReducer[actionSymbol] || actionReducer[actionOnSymbol];\n      return runActionReducerAtPath(state, action, actionReducer, actionMeta.parent);\n    }\n\n    return state;\n  };\n\n  var reducerForCustomReducers = function reducerForCustomReducers(state, action) {\n    return customReducers.reduce(function (acc, _ref) {\n      var parentPath = _ref.parentPath,\n          key = _ref.key,\n          red = _ref.reducer;\n      return simpleProduce(parentPath, acc, function (draft) {\n        draft[key] = red(draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  var rootReducer = function rootReducer(state, action) {\n    var stateAfterActions = reducerForActions(state, action);\n    var next = customReducers.length > 0 ? reducerForCustomReducers(stateAfterActions, action) : stateAfterActions;\n\n    if (state !== next) {\n      computedProperties.forEach(function (_ref2) {\n        var parentPath = _ref2.parentPath,\n            bindComputedProperty = _ref2.bindComputedProperty;\n        bindComputedProperty(get(parentPath, next));\n      });\n    }\n\n    return next;\n  };\n\n  return rootReducer;\n}\n\nvar noopStorage = {\n  getItem: function getItem() {\n    return undefined;\n  },\n  setItem: function setItem() {\n    return undefined;\n  },\n  removeItem: function removeItem() {\n    return undefined;\n  }\n};\n\nfunction getStorage(storageName) {\n  try {\n    if (typeof window !== 'undefined' && typeof window[storageName] !== 'undefined') {\n      return window[storageName];\n    }\n\n    return noopStorage;\n  } catch (_) {\n    return noopStorage;\n  }\n}\n\nvar localStorage = getStorage('localStorage');\nvar sessionStorage = getStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers) {\n  if (storage === void 0) {\n    storage = sessionStorage;\n  }\n\n  if (transformers === void 0) {\n    transformers = [];\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage;\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage;\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\"Invalid storage provider specified for Easy Peasy persist: \" + storage + \"\\nValid values include \\\"localStorage\\\", \\\"sessionStorage\\\" or a custom storage engine.\");\n      }\n\n      storage = noopStorage;\n    }\n  }\n\n  var outTransformers = transformers.reverse();\n\n  var serialize = function serialize(data, key) {\n    var simpleKey = key.substr(key.indexOf('@') + 1);\n    var transformed = transformers.reduce(function (acc, cur) {\n      return cur.in(acc, simpleKey);\n    }, data);\n    return storage === localStorage || storage === sessionStorage ? JSON.stringify({\n      data: transformed\n    }) : transformed;\n  };\n\n  var deserialize = function deserialize(data, key) {\n    var simpleKey = key.substr(key.indexOf('@') + 1);\n    var result = storage === localStorage || storage === sessionStorage ? JSON.parse(data).data : data;\n    return outTransformers.reduce(function (acc, cur) {\n      return cur.out(acc, simpleKey);\n    }, result);\n  };\n\n  var isAsync = isPromise(storage.getItem('_'));\n  return {\n    isAsync: isAsync,\n    getItem: function getItem(key) {\n      if (isAsync) {\n        return storage.getItem(key).then(function (wrapped) {\n          return wrapped != null ? deserialize(wrapped, key) : undefined;\n        });\n      }\n\n      var wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped, key) : undefined;\n    },\n    setItem: function setItem(key, data) {\n      return storage.setItem(key, serialize(data, key));\n    },\n    removeItem: function removeItem(key) {\n      return storage.removeItem(key);\n    }\n  };\n}\n\nfunction extractPersistConfig(path, persistDefinition) {\n  if (persistDefinition === void 0) {\n    persistDefinition = {};\n  }\n\n  return {\n    path: path,\n    config: {\n      blacklist: persistDefinition.blacklist || [],\n      mergeStrategy: persistDefinition.mergeStrategy || 'merge',\n      storage: createStorageWrapper(persistDefinition.storage, persistDefinition.transformers),\n      whitelist: persistDefinition.whitelist || []\n    }\n  };\n}\n\nfunction resolvePersistTargets(target, whitelist, blacklist) {\n  var targets = Object.keys(target);\n\n  if (whitelist.length > 0) {\n    targets = targets.reduce(function (acc, cur) {\n      if (whitelist.findIndex(function (x) {\n        return x === cur;\n      }) !== -1) {\n        return [].concat(acc, [cur]);\n      }\n\n      return acc;\n    }, []);\n  }\n\n  if (blacklist.length > 0) {\n    targets = targets.reduce(function (acc, cur) {\n      if (blacklist.findIndex(function (x) {\n        return x === cur;\n      }) !== -1) {\n        return acc;\n      }\n\n      return [].concat(acc, [cur]);\n    }, []);\n  }\n\n  return targets;\n}\n\nfunction createPersistor(persistKey, references) {\n  return debounce(function () {\n    references.internals.persistenceConfig.forEach(function (_ref) {\n      var path = _ref.path,\n          config = _ref.config;\n      var storage = config.storage,\n          whitelist = config.whitelist,\n          blacklist = config.blacklist;\n      var state = references.getState();\n      var persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      var targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n      targets.forEach(function (key) {\n        var targetPath = [].concat(path, [key]);\n        storage.setItem(persistKey(targetPath), get(targetPath, state));\n      });\n    });\n  }, 1000);\n}\n\nfunction createPersistMiddleware(persistor, references) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        var state = next(action);\n\n        if (action && action.type !== '@action.ePRS' && references.internals.persistenceConfig.length > 0) {\n          persistor(state);\n        }\n\n        return state;\n      };\n    };\n  };\n}\n\nfunction createPersistenceClearer(persistKey, references) {\n  return function () {\n    return new Promise(function (resolve, reject) {\n      references.internals.persistenceConfig.forEach(function (_ref2) {\n        var path = _ref2.path,\n            config = _ref2.config;\n        var storage = config.storage,\n            whitelist = config.whitelist,\n            blacklist = config.blacklist;\n        var persistRoot = get(path, references.getState());\n        var targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n\n        if (targets.length > 0) {\n          Promise.all(targets.map(function (key) {\n            var targetPath = [].concat(path, [key]);\n            return storage.removeItem(persistKey(targetPath));\n          })).then(function () {\n            return resolve();\n          }, reject);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n}\n\nfunction rehydrateStateFromPersistIfNeeded(persistKey, replaceState, references) {\n  // If we have any persist configs we will attemp to perform a state rehydration\n  var resolveRehydration = Promise.resolve();\n\n  if (references.internals.persistenceConfig.length > 0) {\n    references.internals.persistenceConfig.forEach(function (persistInstance) {\n      var path = persistInstance.path,\n          config = persistInstance.config;\n      var blacklist = config.blacklist,\n          mergeStrategy = config.mergeStrategy,\n          storage = config.storage,\n          whitelist = config.whitelist;\n      var state = references.internals.defaultState;\n      var persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      var targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n\n      var applyRehydrationStrategy = function applyRehydrationStrategy(originalState, rehydratedState) {\n        if (mergeStrategy === 'overwrite') {\n          set(path, originalState, rehydratedState);\n        } else if (mergeStrategy === 'merge') {\n          var target = get(path, originalState);\n          Object.keys(rehydratedState).forEach(function (key) {\n            target[key] = rehydratedState[key];\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          var _target = get(path, originalState);\n\n          var setAt = function setAt(currentTarget, currentNext) {\n            Object.keys(currentNext).forEach(function (key) {\n              var data = currentNext[key];\n\n              if (isPlainObject(data)) {\n                if (!isPlainObject(currentTarget[key])) {\n                  currentTarget[key] = {};\n                }\n\n                setAt(currentTarget[key], data);\n              } else {\n                currentTarget[key] = data;\n              }\n            });\n          };\n\n          setAt(_target, rehydratedState);\n        }\n      };\n\n      if (storage.isAsync) {\n        var asyncStateResolvers = targets.reduce(function (acc, key) {\n          var targetPath = [].concat(path, [key]);\n          var dataPromise = storage.getItem(persistKey(targetPath));\n\n          if (isPromise(dataPromise)) {\n            acc.push({\n              key: key,\n              dataPromise: dataPromise\n            });\n          }\n\n          return acc;\n        }, []);\n\n        if (asyncStateResolvers.length > 0) {\n          resolveRehydration = Promise.all(asyncStateResolvers.map(function (x) {\n            return x.dataPromise;\n          })).then(function (resolvedData) {\n            var next = resolvedData.reduce(function (acc, cur, idx) {\n              var key = asyncStateResolvers[idx].key;\n\n              if (cur !== undefined) {\n                acc[key] = cur;\n              }\n\n              return acc;\n            }, {});\n\n            if (Object.keys(next).length === 0) {\n              return;\n            }\n\n            applyRehydrationStrategy(state, next);\n            replaceState(state);\n          });\n        }\n      } else {\n        var next = targets.reduce(function (acc, key) {\n          var targetPath = [].concat(path, [key]);\n          var data = storage.getItem(persistKey(targetPath));\n\n          if (data !== undefined) {\n            acc[key] = data;\n          }\n\n          return acc;\n        }, {});\n        applyRehydrationStrategy(state, next);\n        replaceState(state);\n      }\n    });\n  }\n\n  return resolveRehydration;\n}\n\nfunction createActionCreator(actionDefinition, meta, references) {\n  var prefix = actionDefinition[actionSymbol] ? '@action' : '@actionOn';\n  var type = prefix + \".\" + meta.path.join('.');\n  var actionMeta = actionDefinition[actionSymbol] || actionDefinition[actionOnSymbol];\n  actionMeta.actionName = meta.key;\n  actionMeta.type = type;\n  actionMeta.parent = meta.parent;\n  actionMeta.path = meta.path;\n\n  var actionCreator = function actionCreator(payload) {\n    var action = {\n      type: type,\n      payload: payload\n    };\n\n    if (actionDefinition[actionOnSymbol] && actionMeta.resolvedTargets) {\n      payload.resolvedTargets = [].concat(actionMeta.resolvedTargets);\n    }\n\n    var result = references.dispatch(action);\n    return result;\n  };\n\n  actionCreator.type = type;\n  return actionCreator;\n}\n\nfunction createThunkHandler(thunkDefinition, meta, references, injections, actionCreators) {\n  var thunkMeta = thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\n  return function (payload) {\n    var helpers = {\n      dispatch: references.dispatch,\n      getState: function getState() {\n        return get(meta.parent, references.getState());\n      },\n      getStoreActions: function getStoreActions() {\n        return actionCreators;\n      },\n      getStoreState: references.getState,\n      injections: injections,\n      meta: meta\n    };\n\n    if (thunkDefinition[thunkOnSymbol] && thunkMeta.resolvedTargets) {\n      payload.resolvedTargets = [].concat(thunkMeta.resolvedTargets);\n    }\n\n    return thunkDefinition(get(meta.parent, actionCreators), payload, helpers);\n  };\n}\n\nfunction createThunkActionsCreator(thunkDefinition, meta, references, thunkHandler) {\n  var prefix = thunkDefinition[thunkSymbol] ? '@thunk' : '@thunkOn';\n  var type = prefix + \".\" + meta.path.join('.');\n  var startType = type + \"(start)\";\n  var successType = type + \"(success)\";\n  var failType = type + \"(fail)\";\n  var thunkMeta = thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\n  thunkMeta.type = type;\n  thunkMeta.actionName = meta.key;\n  thunkMeta.parent = meta.parent;\n  thunkMeta.path = meta.path;\n\n  var actionCreator = function actionCreator(payload) {\n    var dispatchError = function dispatchError(err) {\n      references.dispatch({\n        type: failType,\n        payload: payload,\n        error: err\n      });\n      references.dispatch({\n        type: type,\n        payload: payload,\n        error: err\n      });\n    };\n\n    var dispatchSuccess = function dispatchSuccess(result) {\n      references.dispatch({\n        type: successType,\n        payload: payload,\n        result: result\n      });\n      references.dispatch({\n        type: type,\n        payload: payload,\n        result: result\n      });\n    };\n\n    references.dispatch({\n      type: startType,\n      payload: payload\n    });\n\n    try {\n      var result = references.dispatch(function () {\n        return thunkHandler(payload);\n      });\n\n      if (isPromise(result)) {\n        return result.then(function (resolved) {\n          dispatchSuccess(resolved);\n          return resolved;\n        }).catch(function (err) {\n          dispatchError(err);\n          throw err;\n        });\n      }\n\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      dispatchError(err);\n      throw err;\n    }\n  };\n\n  actionCreator.type = type;\n  actionCreator.startType = startType;\n  actionCreator.successType = successType;\n  actionCreator.failType = failType;\n  return actionCreator;\n}\n\nfunction createListenerMiddleware(references) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        var result = next(action);\n\n        if (action && references.internals.listenerActionMap[action.type] && references.internals.listenerActionMap[action.type].length > 0) {\n          var sourceAction = references.internals.actionCreatorDict[action.type];\n          references.internals.listenerActionMap[action.type].forEach(function (actionCreator) {\n            actionCreator({\n              type: sourceAction ? sourceAction.type : action.type,\n              payload: action.payload,\n              error: action.error,\n              result: action.result\n            });\n          });\n        }\n\n        return result;\n      };\n    };\n  };\n}\n\nfunction bindListenerDefinitions(listenerDefinitions, actionCreators, actionCreatorDict, listenerActionMap) {\n  listenerDefinitions.forEach(function (listenerActionOrThunk) {\n    var listenerMeta = listenerActionOrThunk[actionOnSymbol] || listenerActionOrThunk[thunkOnSymbol];\n    var targets = listenerMeta.targetResolver(get(listenerMeta.parent, actionCreators), actionCreators);\n    var targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(function (acc, target) {\n      if (typeof target === 'function' && target.type && actionCreatorDict[target.type]) {\n        acc.push(target.type);\n      } else if (typeof target === 'string') {\n        acc.push(target);\n      }\n\n      return acc;\n    }, []);\n    listenerMeta.resolvedTargets = targetTypes;\n    targetTypes.forEach(function (targetType) {\n      var listenerReg = listenerActionMap[targetType] || [];\n      listenerReg.push(actionCreatorDict[listenerMeta.type]);\n      listenerActionMap[targetType] = listenerReg;\n    });\n  });\n}\n\nfunction createComputedPropertyBinder(parentPath, key, definition, computedState, references) {\n  var computedMeta = definition[computedSymbol];\n  var memoisedResultFn = memoizerific(1)(definition);\n  return function createComputedProperty(o) {\n    Object.defineProperty(o, key, {\n      configurable: true,\n      enumerable: true,\n      get: function get$1() {\n        var storeState;\n\n        if (computedState.isInReducer) {\n          storeState = computedState.currentState;\n        } else if (references.getState == null) {\n          return undefined;\n        } else {\n          try {\n            storeState = references.getState();\n          } catch (err) {\n            if (process.env.NODE_ENV === 'development') {\n              console.warn('Invalid access attempt to a computed property');\n            }\n\n            return undefined;\n          }\n        }\n\n        var state = get(parentPath, storeState);\n        var inputs = computedMeta.stateResolvers.map(function (resolver) {\n          return resolver(state, storeState);\n        });\n        return memoisedResultFn.apply(void 0, inputs);\n      }\n    });\n  };\n}\n\nfunction createComputedPropertiesMiddleware(references) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        references.internals.computedState.currentState = store.getState();\n        references.internals.computedState.isInReducer = true;\n        return next(action);\n      };\n    };\n  };\n}\n\nfunction extractDataFromModel(model, initialState, injections, references) {\n  var defaultState = initialState;\n  var actionCreatorDict = {};\n  var actionCreators = {};\n  var actionReducersDict = {};\n  var actionThunks = {};\n  var computedProperties = [];\n  var customReducers = [];\n  var listenerActionCreators = {};\n  var listenerActionMap = {};\n  var listenerDefinitions = [];\n  var persistenceConfig = [];\n  var computedState = {\n    isInReducer: false,\n    currentState: defaultState\n  };\n\n  var recursiveExtractFromModel = function recursiveExtractFromModel(current, parentPath) {\n    return Object.keys(current).forEach(function (key) {\n      var value = current[key];\n      var path = [].concat(parentPath, [key]);\n      var meta = {\n        parent: parentPath,\n        path: path,\n        key: key\n      };\n\n      var handleValueAsState = function handleValueAsState() {\n        var initialParentRef = get(parentPath, initialState);\n\n        if (initialParentRef && key in initialParentRef) {\n          set(path, defaultState, initialParentRef[key]);\n        } else {\n          set(path, defaultState, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (typeof value === 'function') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          var actionReducer = value;\n          var actionCreator = createActionCreator(value, meta, references);\n          actionCreatorDict[actionCreator.type] = actionCreator;\n          actionReducersDict[actionCreator.type] = actionReducer;\n\n          if (meta.key !== 'ePRS') {\n            if (value[actionOnSymbol]) {\n              listenerDefinitions.push(value);\n              set(path, listenerActionCreators, actionCreator);\n            } else {\n              set(path, actionCreators, actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          var thunkHandler = createThunkHandler(value, meta, references, injections, actionCreators);\n\n          var _actionCreator = createThunkActionsCreator(value, meta, references, thunkHandler);\n\n          set(path, actionThunks, thunkHandler);\n          actionCreatorDict[_actionCreator.type] = _actionCreator;\n\n          if (value[thunkOnSymbol]) {\n            listenerDefinitions.push(value);\n            set(path, listenerActionCreators, _actionCreator);\n          } else {\n            set(path, actionCreators, _actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          var parent = get(parentPath, defaultState);\n          var bindComputedProperty = createComputedPropertyBinder(parentPath, key, value, computedState, references);\n          bindComputedProperty(parent);\n          computedProperties.push({\n            key: key,\n            parentPath: parentPath,\n            bindComputedProperty: bindComputedProperty\n          });\n        } else if (value[reducerSymbol]) {\n          customReducers.push({\n            key: key,\n            parentPath: parentPath,\n            reducer: value\n          });\n        } else {\n          handleValueAsState();\n        }\n      } else if (isPlainObject(value)) {\n        var existing = get(path, defaultState);\n\n        if (existing == null) {\n          set(path, defaultState, {});\n        }\n\n        recursiveExtractFromModel(value, path);\n      } else {\n        handleValueAsState();\n      }\n    });\n  };\n\n  recursiveExtractFromModel(model, []);\n  bindListenerDefinitions(listenerDefinitions, actionCreators, actionCreatorDict, listenerActionMap);\n  return {\n    actionCreatorDict: actionCreatorDict,\n    actionCreators: actionCreators,\n    actionReducersDict: actionReducersDict,\n    computedProperties: computedProperties,\n    customReducers: customReducers,\n    computedState: computedState,\n    defaultState: defaultState,\n    listenerActionCreators: listenerActionCreators,\n    listenerActionMap: listenerActionMap,\n    persistenceConfig: persistenceConfig\n  };\n}\n\nfunction createStoreInternals(_ref) {\n  var disableImmer = _ref.disableImmer,\n      initialState = _ref.initialState,\n      injections = _ref.injections,\n      model = _ref.model,\n      reducerEnhancer = _ref.reducerEnhancer,\n      references = _ref.references;\n\n  var _extractDataFromModel = extractDataFromModel(model, initialState, injections, references),\n      actionCreatorDict = _extractDataFromModel.actionCreatorDict,\n      actionCreators = _extractDataFromModel.actionCreators,\n      actionReducersDict = _extractDataFromModel.actionReducersDict,\n      computedState = _extractDataFromModel.computedState,\n      computedProperties = _extractDataFromModel.computedProperties,\n      customReducers = _extractDataFromModel.customReducers,\n      defaultState = _extractDataFromModel.defaultState,\n      listenerActionCreators = _extractDataFromModel.listenerActionCreators,\n      listenerActionMap = _extractDataFromModel.listenerActionMap,\n      persistenceConfig = _extractDataFromModel.persistenceConfig;\n\n  var rootReducer = createReducer(disableImmer, actionReducersDict, customReducers, computedProperties);\n  return {\n    actionCreatorDict: actionCreatorDict,\n    actionCreators: actionCreators,\n    computedProperties: computedProperties,\n    computedState: computedState,\n    defaultState: defaultState,\n    listenerActionCreators: listenerActionCreators,\n    listenerActionMap: listenerActionMap,\n    persistenceConfig: persistenceConfig,\n    reducer: reducerEnhancer(rootReducer)\n  };\n}\n\nfunction createStore(model, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var modelClone = deepCloneStateWithoutComputed(model);\n  var _options = options,\n      compose$1 = _options.compose,\n      _options$devTools = _options.devTools,\n      devTools = _options$devTools === void 0 ? true : _options$devTools,\n      _options$disableImmer = _options.disableImmer,\n      disableImmer = _options$disableImmer === void 0 ? false : _options$disableImmer,\n      _options$enhancers = _options.enhancers,\n      enhancers = _options$enhancers === void 0 ? [] : _options$enhancers,\n      _options$initialState = _options.initialState,\n      initialState = _options$initialState === void 0 ? {} : _options$initialState,\n      injections = _options.injections,\n      _options$middleware = _options.middleware,\n      middleware = _options$middleware === void 0 ? [] : _options$middleware,\n      _options$mockActions = _options.mockActions,\n      mockActions = _options$mockActions === void 0 ? false : _options$mockActions,\n      _options$name = _options.name,\n      storeName = _options$name === void 0 ? \"EasyPeasyStore\" : _options$name,\n      _options$reducerEnhan = _options.reducerEnhancer,\n      reducerEnhancer = _options$reducerEnhan === void 0 ? function (rootReducer) {\n    return rootReducer;\n  } : _options$reducerEnhan;\n\n  var bindReplaceState = function bindReplaceState(modelDef) {\n    return _extends({}, modelDef, {\n      ePRS: action(function (_, payload) {\n        return payload;\n      })\n    });\n  };\n\n  var references = {};\n  var modelDefinition = bindReplaceState(modelClone);\n  var mockedActions = [];\n\n  var persistKey = function persistKey(targetPath) {\n    return \"[\" + storeName + \"]@\" + targetPath.join('.');\n  };\n\n  var persistor = createPersistor(persistKey, references);\n  var persistMiddleware = createPersistMiddleware(persistor, references);\n  var clearPersistance = createPersistenceClearer(persistKey, references);\n\n  var replaceState = function replaceState(nextState) {\n    return references.internals.actionCreatorDict['@action.ePRS'](nextState);\n  };\n\n  var bindStoreInternals = function bindStoreInternals(state) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    references.internals = createStoreInternals({\n      disableImmer: disableImmer,\n      initialState: state,\n      injections: injections,\n      model: modelDefinition,\n      reducerEnhancer: reducerEnhancer,\n      references: references\n    });\n  };\n\n  var mockActionsMiddleware = function mockActionsMiddleware() {\n    return function () {\n      return function (action) {\n        if (action != null) {\n          mockedActions.push(action);\n        }\n\n        return undefined;\n      };\n    };\n  };\n\n  var composeEnhancers = compose$1 || (devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n    name: storeName\n  }) : compose);\n  bindStoreInternals(initialState);\n  var easyPeasyMiddleware = [createComputedPropertiesMiddleware(references), reduxThunk].concat(middleware, [createListenerMiddleware(references), persistMiddleware]);\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  var store = createStore$1(references.internals.reducer, references.internals.defaultState, composeEnhancers.apply(void 0, [applyMiddleware.apply(void 0, easyPeasyMiddleware)].concat(enhancers)));\n  store.subscribe(function () {\n    references.internals.computedState.isInReducer = false;\n  });\n  references.dispatch = store.dispatch;\n  references.getState = store.getState;\n\n  var bindActionCreators = function bindActionCreators() {\n    Object.keys(store.dispatch).forEach(function (actionsKey) {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(references.internals.actionCreators).forEach(function (key) {\n      store.dispatch[key] = references.internals.actionCreators[key];\n    });\n  };\n\n  bindActionCreators();\n\n  var rebindStore = function rebindStore(removeKey) {\n    var currentState = store.getState();\n\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n\n    bindStoreInternals(currentState);\n    store.replaceReducer(references.internals.reducer);\n    replaceState(references.internals.defaultState);\n    bindActionCreators();\n  };\n\n  var _resolveRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, references);\n\n  return Object.assign(store, {\n    addModel: function addModel(key, modelForKey) {\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\"easy-peasy: The store model already contains a model definition for \\\"\" + key + \"\\\"\");\n        store.removeModel(key);\n      }\n\n      modelDefinition[key] = modelForKey;\n      rebindStore();\n    },\n    clearMockedActions: function clearMockedActions() {\n      mockedActions = [];\n    },\n    getActions: function getActions() {\n      return references.internals.actionCreators;\n    },\n    getListeners: function getListeners() {\n      return references.internals.listenerActionCreators;\n    },\n    getMockedActions: function getMockedActions() {\n      return [].concat(mockedActions);\n    },\n    persist: {\n      clear: clearPersistance,\n      flush: function flush() {\n        return persistor.flush();\n      },\n      resolveRehydration: function resolveRehydration() {\n        return _resolveRehydration;\n      }\n    },\n    reconfigure: function reconfigure(newModel) {\n      modelDefinition = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: function removeModel(key) {\n      if (!modelDefinition[key]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\"easy-peasy: The store model does not contain a model definition for \\\"\" + key + \"\\\"\");\n        }\n\n        return;\n      }\n\n      delete modelDefinition[key];\n      rebindStore(key);\n    }\n  });\n}\n/* eslint-disable react/prop-types */\n\n\nfunction createContextStore(model, config) {\n  var StoreContext = createContext();\n\n  function Provider(_ref) {\n    var children = _ref.children,\n        initialData = _ref.initialData;\n    var store = useMemo(function () {\n      return createStore(typeof model === 'function' ? model(initialData) : model, config);\n    }, []);\n    return React.createElement(StoreContext.Provider, {\n      value: store\n    }, children);\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider: Provider,\n    useStore: useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext)\n  };\n}\n/**\n * Some good references on the topic of reinitialisation:\n * - https://github.com/facebook/react/issues/14830\n */\n\n\nfunction createComponentStore(model, config) {\n  return function useLocalStore(initialData) {\n    var store = useMemo(function () {\n      return createStore(typeof model === 'function' ? model(initialData) : model, config);\n    }, []);\n    var previousStateRef = useRef(store.getState());\n\n    var _useState = useState(function () {\n      return store.getState();\n    }),\n        currentState = _useState[0],\n        setCurrentState = _useState[1];\n\n    useEffect(function () {\n      return store.subscribe(function () {\n        var nextState = store.getState();\n\n        if (previousStateRef.current !== nextState) {\n          previousStateRef.current = nextState;\n          setCurrentState(nextState);\n        }\n      });\n    }, [store]);\n    return [currentState, store.getActions()];\n  };\n}\n/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\n\nfunction createTransform(inbound, outbound, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var whitelist = config.whitelist || null;\n  var blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: function _in(data, key, fullState) {\n      return !whitelistBlacklistCheck(key) && inbound ? inbound(data, key, fullState) : data;\n    },\n    out: function out(data, key, fullState) {\n      return !whitelistBlacklistCheck(key) && outbound ? outbound(data, key, fullState) : data;\n    }\n  };\n}\n\nfunction StoreProvider(_ref) {\n  var children = _ref.children,\n      store = _ref.store;\n  return React.createElement(StoreContext.Provider, {\n    value: store\n  }, children);\n}\n/**\n * The auto freeze feature of immer doesn't seem to work in our testing. We have\n * explicitly disabled it to avoid perf issues.\n */\n\n\nsetAutoFreeze(false);\nexport { StoreProvider, action, actionOn, computed, createComponentStore, createContextStore, createStore, createTransform, createTypedHooks, debug, memo, persist, reducer, thunk, thunkOn, useStore, useStoreActions, useStoreDispatch, useStoreRehydrated, useStoreState };","map":{"version":3,"sources":["../src/context.js","../src/hooks.js","../src/constants.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/actions.js","../src/thunks.js","../src/listeners.js","../src/computed-properties.js","../src/extract-data-from-model.js","../src/create-store-internals.js","../src/create-store.js","../src/create-context-store.js","../src/create-component-store.js","../src/create-transform.js","../src/provider.js","../src/index.js"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","mapState","process","errorMessage","err","checkMapState","newState","isStateEqual","equalityFn","unsubscribe","useStoreState","createStoreStateHook","mapActions","useStoreActions","createStoreActionsHook","useStoreDispatch","createStoreDispatchHook","rehydrated","setRehydrated","useState","useEffect","useStoreRehydrated","createStoreRehydratedHook","useStore","actionSymbol","actionOnSymbol","computedSymbol","persistSymbol","reducerSymbol","thunkOnSymbol","thunkSymbol","debug","isDraft","original","memo","memoizerific","actionOn","fn","targetResolver","action","defaultStateResolvers","computed","stateResolvers","fnOrStateResolvers","persist","thunkOn","thunk","reducer","deepCloneStateWithoutComputed","recursiveClone","next","Object","acc","current","isPlainObject","isPromise","x","currentPath","key","newify","set","path","target","value","idx","disableImmer","get","draft","createDraft","result","finishDraft","parentPath","parent","simpleProduce","createSimpleProduce","runActionReducerAtPath","actionReducer","reducerForActions","actionReducersDict","actionMeta","reducerForCustomReducers","red","rootReducer","stateAfterActions","customReducers","state","computedProperties","bindComputedProperty","noopStorage","getItem","setItem","removeItem","window","localStorage","getStorage","sessionStorage","storage","transformers","console","outTransformers","serialize","simpleKey","transformed","cur","data","deserialize","JSON","isAsync","wrapped","persistDefinition","config","blacklist","mergeStrategy","createStorageWrapper","whitelist","targets","debounce","references","persistRoot","resolvePersistTargets","targetPath","persistKey","persistor","Promise","resolve","resolveRehydration","persistInstance","applyRehydrationStrategy","rehydratedState","setAt","currentNext","currentTarget","asyncStateResolvers","dataPromise","replaceState","prefix","actionDefinition","type","meta","actionCreator","payload","thunkMeta","thunkDefinition","helpers","dispatch","getState","getStoreActions","getStoreState","injections","startType","successType","failType","dispatchError","error","dispatchSuccess","thunkHandler","sourceAction","listenerDefinitions","listenerMeta","listenerActionOrThunk","targetTypes","Array","actionCreatorDict","listenerReg","listenerActionMap","computedMeta","definition","memoisedResultFn","configurable","enumerable","computedState","storeState","inputs","resolver","defaultState","actionCreators","actionThunks","listenerActionCreators","persistenceConfig","isInReducer","currentState","recursiveExtractFromModel","handleValueAsState","initialParentRef","extractPersistConfig","createActionCreator","createThunkHandler","createThunkActionsCreator","createComputedPropertyBinder","existing","bindListenerDefinitions","initialState","model","reducerEnhancer","extractDataFromModel","createReducer","options","modelClone","compose","devTools","enhancers","middleware","mockActions","storeName","bindReplaceState","ePRS","modelDefinition","mockedActions","createPersistor","persistMiddleware","createPersistMiddleware","clearPersistance","createPersistenceClearer","bindStoreInternals","createStoreInternals","mockActionsMiddleware","composeEnhancers","name","easyPeasyMiddleware","createComputedPropertiesMiddleware","createListenerMiddleware","reduxCreateStore","applyMiddleware","bindActionCreators","rebindStore","rehydrateStateFromPersistIfNeeded","addModel","clearMockedActions","getActions","getListeners","getMockedActions","clear","flush","reconfigure","removeModel","children","initialData","useMemo","createStore","Provider","previousStateRef","setCurrentState","nextState","in","whitelistBlacklistCheck","inbound","out","outbound","setAutoFreeze"],"mappings":"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","sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer(s => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `An error occurred trying to map state in a useStoreState hook: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nThis error may be related to the following error:\\n${subscriptionMapStateError.current.stack}\\n\\nOriginal stack trace:`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","export const actionSymbol = 'a';\nexport const actionOnSymbol = 'aO';\nexport const computedSymbol = 'c';\nexport const persistSymbol = 'p';\nexport const reducerSymbol = 'r';\nexport const thunkOnSymbol = 'tO';\nexport const thunkSymbol = 't';\n","import { isDraft, original } from 'immer-peasy';\nimport memoizerific from 'memoizerific';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = state => {\n  if (isDraft(state)) {\n    return original(state);\n  }\n  return state;\n};\n\nexport const memo = (fn, cacheSize) => memoizerific(cacheSize)(fn);\n\nexport const actionOn = (targetResolver, fn) => {\n  fn[actionOnSymbol] = {\n    targetResolver,\n  };\n  return fn;\n};\n\nexport const action = fn => {\n  fn[actionSymbol] = {};\n  return fn;\n};\n\nconst defaultStateResolvers = [state => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    fn[computedSymbol] = {\n      stateResolvers: fnOrStateResolvers,\n    };\n    return fn;\n  }\n  fnOrStateResolvers[computedSymbol] = {\n    stateResolvers: defaultStateResolvers,\n  };\n  return fnOrStateResolvers;\n};\n\nexport const persist = (model, config) => {\n  return {\n    ...model,\n    [persistSymbol]: config,\n  };\n};\n\nexport const thunkOn = (targetResolver, fn) => {\n  fn[thunkOnSymbol] = {\n    targetResolver,\n  };\n  return fn;\n};\n\nexport const thunk = fn => {\n  fn[thunkSymbol] = {};\n  return fn;\n};\n\nexport const reducer = fn => {\n  fn[reducerSymbol] = {};\n  return fn;\n};\n","import isPlainObject from 'is-plain-object';\nimport { createDraft, finishDraft, isDraft } from 'immer-peasy';\n\nexport const deepCloneStateWithoutComputed = source => {\n  const recursiveClone = current => {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach(key => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  };\n  return recursiveClone(source);\n};\n\nexport const isPromise = x => {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n};\n\nexport function get(path, target) {\n  return path.reduce((acc, cur) => {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport const set = (path, target, value) => {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach(key => {\n        delete target[key];\n      });\n      Object.keys(value).forEach(key => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n};\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (path.length === 0) {\n      const draft = createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? finishDraft(result) : result;\n      }\n      return finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return finishDraft(draft);\n  };\n}\n","import { createSimpleProduce, get } from './lib';\nimport { actionSymbol, actionOnSymbol } from './constants';\n\nexport default function createReducer(\n  disableImmer,\n  actionReducersDict,\n  customReducers,\n  computedProperties,\n) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) => {\n    return simpleProduce(path, state, draft =>\n      actionReducer(draft, action.payload),\n    );\n  };\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = actionReducersDict[action.type];\n    if (actionReducer) {\n      const actionMeta =\n        actionReducer[actionSymbol] || actionReducer[actionOnSymbol];\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionMeta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) => {\n    return customReducers.reduce((acc, { parentPath, key, reducer: red }) => {\n      return simpleProduce(parentPath, acc, draft => {\n        draft[key] = red(draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      customReducers.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      computedProperties.forEach(({ parentPath, bindComputedProperty }) => {\n        bindComputedProperty(get(parentPath, next));\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import debounce from 'debounce';\nimport isPlainObject from 'is-plain-object';\nimport { deepCloneStateWithoutComputed, get, isPromise, set } from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nfunction getStorage(storageName) {\n  try {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window[storageName] !== 'undefined'\n    ) {\n      return window[storageName];\n    }\n    return noopStorage;\n  } catch (_) {\n    return noopStorage;\n  }\n}\n\nconst localStorage = getStorage('localStorage');\nconst sessionStorage = getStorage('sessionStorage');\n\nfunction createStorageWrapper(storage = sessionStorage, transformers = []) {\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage;\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage;\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Invalid storage provider specified for Easy Peasy persist: ${storage}\\nValid values include \"localStorage\", \"sessionStorage\" or a custom storage engine.`,\n        );\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = transformers.reverse();\n\n  const serialize = (data, key) => {\n    const simpleKey = key.substr(key.indexOf('@') + 1);\n    const transformed = transformers.reduce((acc, cur) => {\n      return cur.in(acc, simpleKey);\n    }, data);\n    return storage === localStorage || storage === sessionStorage\n      ? JSON.stringify({ data: transformed })\n      : transformed;\n  };\n  const deserialize = (data, key) => {\n    const simpleKey = key.substr(key.indexOf('@') + 1);\n    const result =\n      storage === localStorage || storage === sessionStorage\n        ? JSON.parse(data).data\n        : data;\n    return outTransformers.reduce((acc, cur) => {\n      return cur.out(acc, simpleKey);\n    }, result);\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    isAsync,\n    getItem: key => {\n      if (isAsync) {\n        return storage.getItem(key).then(wrapped => {\n          return wrapped != null ? deserialize(wrapped, key) : undefined;\n        });\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped, key) : undefined;\n    },\n    setItem: (key, data) => {\n      return storage.setItem(key, serialize(data, key));\n    },\n    removeItem: key => {\n      return storage.removeItem(key);\n    },\n  };\n}\n\nexport function extractPersistConfig(path, persistDefinition = {}) {\n  return {\n    path,\n    config: {\n      blacklist: persistDefinition.blacklist || [],\n      mergeStrategy: persistDefinition.mergeStrategy || 'merge',\n      storage: createStorageWrapper(\n        persistDefinition.storage,\n        persistDefinition.transformers,\n      ),\n      whitelist: persistDefinition.whitelist || [],\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, whitelist, blacklist) {\n  let targets = Object.keys(target);\n  if (whitelist.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (whitelist.findIndex(x => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (blacklist.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (blacklist.findIndex(x => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nexport function createPersistor(persistKey, references) {\n  return debounce(() => {\n    references.internals.persistenceConfig.forEach(({ path, config }) => {\n      const { storage, whitelist, blacklist } = config;\n      const state = references.getState();\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n      targets.forEach(key => {\n        const targetPath = [...path, key];\n        storage.setItem(persistKey(targetPath), get(targetPath, state));\n      });\n    });\n  }, 1000);\n}\n\nexport function createPersistMiddleware(persistor, references) {\n  return () => next => action => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      references.internals.persistenceConfig.length > 0\n    ) {\n      persistor(state);\n    }\n    return state;\n  };\n}\n\nexport function createPersistenceClearer(persistKey, references) {\n  return () =>\n    new Promise((resolve, reject) => {\n      references.internals.persistenceConfig.forEach(({ path, config }) => {\n        const { storage, whitelist, blacklist } = config;\n        const persistRoot = get(path, references.getState());\n        const targets = resolvePersistTargets(\n          persistRoot,\n          whitelist,\n          blacklist,\n        );\n        if (targets.length > 0) {\n          Promise.all(\n            targets.map(key => {\n              const targetPath = [...path, key];\n              return storage.removeItem(persistKey(targetPath));\n            }),\n          ).then(() => resolve(), reject);\n        } else {\n          resolve();\n        }\n      });\n    });\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  references,\n) {\n  // If we have any persist configs we will attemp to perform a state rehydration\n  let resolveRehydration = Promise.resolve();\n  if (references.internals.persistenceConfig.length > 0) {\n    references.internals.persistenceConfig.forEach(persistInstance => {\n      const { path, config } = persistInstance;\n      const { blacklist, mergeStrategy, storage, whitelist } = config;\n\n      const state = references.internals.defaultState;\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n\n      const applyRehydrationStrategy = (originalState, rehydratedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, originalState, rehydratedState);\n        } else if (mergeStrategy === 'merge') {\n          const target = get(path, originalState);\n          Object.keys(rehydratedState).forEach(key => {\n            target[key] = rehydratedState[key];\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const target = get(path, originalState);\n          const setAt = (currentTarget, currentNext) => {\n            Object.keys(currentNext).forEach(key => {\n              const data = currentNext[key];\n              if (isPlainObject(data)) {\n                if (!isPlainObject(currentTarget[key])) {\n                  currentTarget[key] = {};\n                }\n                setAt(currentTarget[key], data);\n              } else {\n                currentTarget[key] = data;\n              }\n            });\n          };\n          setAt(target, rehydratedState);\n        }\n      };\n\n      if (storage.isAsync) {\n        const asyncStateResolvers = targets.reduce((acc, key) => {\n          const targetPath = [...path, key];\n          const dataPromise = storage.getItem(persistKey(targetPath));\n          if (isPromise(dataPromise)) {\n            acc.push({\n              key,\n              dataPromise,\n            });\n          }\n          return acc;\n        }, []);\n        if (asyncStateResolvers.length > 0) {\n          resolveRehydration = Promise.all(\n            asyncStateResolvers.map(x => x.dataPromise),\n          ).then(resolvedData => {\n            const next = resolvedData.reduce((acc, cur, idx) => {\n              const { key } = asyncStateResolvers[idx];\n              if (cur !== undefined) {\n                acc[key] = cur;\n              }\n              return acc;\n            }, {});\n            if (Object.keys(next).length === 0) {\n              return;\n            }\n            applyRehydrationStrategy(state, next);\n            replaceState(state);\n          });\n        }\n      } else {\n        const next = targets.reduce((acc, key) => {\n          const targetPath = [...path, key];\n          const data = storage.getItem(persistKey(targetPath));\n          if (data !== undefined) {\n            acc[key] = data;\n          }\n          return acc;\n        }, {});\n        applyRehydrationStrategy(state, next);\n        replaceState(state);\n      }\n    });\n  }\n  return resolveRehydration;\n}\n","import { actionSymbol, actionOnSymbol } from './constants';\n\nexport function createActionCreator(actionDefinition, meta, references) {\n  const prefix = actionDefinition[actionSymbol] ? '@action' : '@actionOn';\n  const type = `${prefix}.${meta.path.join('.')}`;\n  const actionMeta =\n    actionDefinition[actionSymbol] || actionDefinition[actionOnSymbol];\n  actionMeta.actionName = meta.key;\n  actionMeta.type = type;\n  actionMeta.parent = meta.parent;\n  actionMeta.path = meta.path;\n\n  const actionCreator = payload => {\n    const action = {\n      type,\n      payload,\n    };\n    if (actionDefinition[actionOnSymbol] && actionMeta.resolvedTargets) {\n      payload.resolvedTargets = [...actionMeta.resolvedTargets];\n    }\n    const result = references.dispatch(action);\n    return result;\n  };\n  actionCreator.type = type;\n\n  return actionCreator;\n}\n","import { thunkSymbol, thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(\n  thunkDefinition,\n  meta,\n  references,\n  injections,\n  actionCreators,\n) {\n  const thunkMeta =\n    thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\n\n  return payload => {\n    const helpers = {\n      dispatch: references.dispatch,\n      getState: () => get(meta.parent, references.getState()),\n      getStoreActions: () => actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta,\n    };\n    if (thunkDefinition[thunkOnSymbol] && thunkMeta.resolvedTargets) {\n      payload.resolvedTargets = [...thunkMeta.resolvedTargets];\n    }\n    return thunkDefinition(get(meta.parent, actionCreators), payload, helpers);\n  };\n}\n\nexport function createThunkActionsCreator(\n  thunkDefinition,\n  meta,\n  references,\n  thunkHandler,\n) {\n  const prefix = thunkDefinition[thunkSymbol] ? '@thunk' : '@thunkOn';\n  const type = `${prefix}.${meta.path.join('.')}`;\n  const startType = `${type}(start)`;\n  const successType = `${type}(success)`;\n  const failType = `${type}(fail)`;\n\n  const thunkMeta =\n    thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\n  thunkMeta.type = type;\n  thunkMeta.actionName = meta.key;\n  thunkMeta.parent = meta.parent;\n  thunkMeta.path = meta.path;\n\n  const actionCreator = payload => {\n    const dispatchError = err => {\n      references.dispatch({\n        type: failType,\n        payload,\n        error: err,\n      });\n      references.dispatch({\n        type,\n        payload,\n        error: err,\n      });\n    };\n    const dispatchSuccess = result => {\n      references.dispatch({\n        type: successType,\n        payload,\n        result,\n      });\n      references.dispatch({\n        type,\n        payload,\n        result,\n      });\n    };\n\n    references.dispatch({\n      type: startType,\n      payload,\n    });\n    try {\n      const result = references.dispatch(() => thunkHandler(payload));\n      if (isPromise(result)) {\n        return result\n          .then(resolved => {\n            dispatchSuccess(resolved);\n            return resolved;\n          })\n          .catch(err => {\n            dispatchError(err);\n            throw err;\n          });\n      }\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      dispatchError(err);\n      throw err;\n    }\n  };\n\n  actionCreator.type = type;\n  actionCreator.startType = startType;\n  actionCreator.successType = successType;\n  actionCreator.failType = failType;\n\n  return actionCreator;\n}\n","import { actionOnSymbol, thunkOnSymbol } from './constants';\nimport { get } from './lib';\n\nexport function createListenerMiddleware(references) {\n  return () => next => action => {\n    const result = next(action);\n    if (\n      action &&\n      references.internals.listenerActionMap[action.type] &&\n      references.internals.listenerActionMap[action.type].length > 0\n    ) {\n      const sourceAction = references.internals.actionCreatorDict[action.type];\n      references.internals.listenerActionMap[action.type].forEach(\n        actionCreator => {\n          actionCreator({\n            type: sourceAction ? sourceAction.type : action.type,\n            payload: action.payload,\n            error: action.error,\n            result: action.result,\n          });\n        },\n      );\n    }\n    return result;\n  };\n}\n\nexport function bindListenerDefinitions(\n  listenerDefinitions,\n  actionCreators,\n  actionCreatorDict,\n  listenerActionMap,\n) {\n  listenerDefinitions.forEach(listenerActionOrThunk => {\n    const listenerMeta =\n      listenerActionOrThunk[actionOnSymbol] ||\n      listenerActionOrThunk[thunkOnSymbol];\n\n    const targets = listenerMeta.targetResolver(\n      get(listenerMeta.parent, actionCreators),\n      actionCreators,\n    );\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.type &&\n          actionCreatorDict[target.type]\n        ) {\n          acc.push(target.type);\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    listenerMeta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach(targetType => {\n      const listenerReg = listenerActionMap[targetType] || [];\n      listenerReg.push(actionCreatorDict[listenerMeta.type]);\n      listenerActionMap[targetType] = listenerReg;\n    });\n  });\n}\n","import memoizerific from 'memoizerific';\nimport { get } from './lib';\nimport { computedSymbol } from './constants';\n\nexport function createComputedPropertyBinder(\n  parentPath,\n  key,\n  definition,\n  computedState,\n  references,\n) {\n  const computedMeta = definition[computedSymbol];\n  const memoisedResultFn = memoizerific(1)(definition);\n  return function createComputedProperty(o) {\n    Object.defineProperty(o, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        let storeState;\n        if (computedState.isInReducer) {\n          storeState = computedState.currentState;\n        } else if (references.getState == null) {\n          return undefined;\n        } else {\n          try {\n            storeState = references.getState();\n          } catch (err) {\n            if (process.env.NODE_ENV === 'development') {\n              console.warn('Invalid access attempt to a computed property');\n            }\n            return undefined;\n          }\n        }\n        const state = get(parentPath, storeState);\n        const inputs = computedMeta.stateResolvers.map(resolver =>\n          resolver(state, storeState),\n        );\n        return memoisedResultFn(...inputs);\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(references) {\n  return store => next => action => {\n    references.internals.computedState.currentState = store.getState();\n    references.internals.computedState.isInReducer = true;\n    return next(action);\n  };\n}\n","import isPlainObject from 'is-plain-object';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerDefinitions } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  references,\n) {\n  const defaultState = initialState;\n  const actionCreatorDict = {};\n  const actionCreators = {};\n  const actionReducersDict = {};\n  const actionThunks = {};\n  const computedProperties = [];\n  const customReducers = [];\n  const listenerActionCreators = {};\n  const listenerActionMap = {};\n  const listenerDefinitions = [];\n  const persistenceConfig = [];\n  const computedState = {\n    isInReducer: false,\n    currentState: defaultState,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach(key => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, defaultState, initialParentRef[key]);\n        } else {\n          set(path, defaultState, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (typeof value === 'function') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const actionReducer = value;\n          const actionCreator = createActionCreator(value, meta, references);\n          actionCreatorDict[actionCreator.type] = actionCreator;\n          actionReducersDict[actionCreator.type] = actionReducer;\n          if (meta.key !== 'ePRS') {\n            if (value[actionOnSymbol]) {\n              listenerDefinitions.push(value);\n              set(path, listenerActionCreators, actionCreator);\n            } else {\n              set(path, actionCreators, actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const thunkHandler = createThunkHandler(\n            value,\n            meta,\n            references,\n            injections,\n            actionCreators,\n          );\n          const actionCreator = createThunkActionsCreator(\n            value,\n            meta,\n            references,\n            thunkHandler,\n          );\n          set(path, actionThunks, thunkHandler);\n          actionCreatorDict[actionCreator.type] = actionCreator;\n          if (value[thunkOnSymbol]) {\n            listenerDefinitions.push(value);\n            set(path, listenerActionCreators, actionCreator);\n          } else {\n            set(path, actionCreators, actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, defaultState);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            computedState,\n            references,\n          );\n          bindComputedProperty(parent);\n          computedProperties.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          customReducers.push({ key, parentPath, reducer: value });\n        } else {\n          handleValueAsState();\n        }\n      } else if (isPlainObject(value)) {\n        const existing = get(path, defaultState);\n        if (existing == null) {\n          set(path, defaultState, {});\n        }\n        recursiveExtractFromModel(value, path);\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerDefinitions(\n    listenerDefinitions,\n    actionCreators,\n    actionCreatorDict,\n    listenerActionMap,\n  );\n\n  return {\n    actionCreatorDict,\n    actionCreators,\n    actionReducersDict,\n    computedProperties,\n    customReducers,\n    computedState,\n    defaultState,\n    listenerActionCreators,\n    listenerActionMap,\n    persistenceConfig,\n  };\n}\n","import createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\n\nexport default function createStoreInternals({\n  disableImmer,\n  initialState,\n  injections,\n  model,\n  reducerEnhancer,\n  references,\n}) {\n  const {\n    actionCreatorDict,\n    actionCreators,\n    actionReducersDict,\n    computedState,\n    computedProperties,\n    customReducers,\n    defaultState,\n    listenerActionCreators,\n    listenerActionMap,\n    persistenceConfig,\n  } = extractDataFromModel(model, initialState, injections, references);\n\n  const rootReducer = createReducer(\n    disableImmer,\n    actionReducersDict,\n    customReducers,\n    computedProperties,\n  );\n\n  return {\n    actionCreatorDict,\n    actionCreators,\n    computedProperties,\n    computedState,\n    defaultState,\n    listenerActionCreators,\n    listenerActionMap,\n    persistenceConfig,\n    reducer: reducerEnhancer(rootReducer),\n  };\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createStoreInternals from './create-store-internals';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  createPersistenceClearer,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { deepCloneStateWithoutComputed } from './lib';\n\nexport default function createStore(model, options = {}) {\n  const modelClone = deepCloneStateWithoutComputed(model);\n  const {\n    compose,\n    devTools = true,\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections,\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    reducerEnhancer = rootReducer => rootReducer,\n  } = options;\n\n  const bindReplaceState = modelDef => {\n    return {\n      ...modelDef,\n      ePRS: helpers.action((_, payload) => payload),\n    };\n  };\n\n  const references = {};\n\n  let modelDefinition = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = targetPath => `[${storeName}]@${targetPath.join('.')}`;\n  const persistor = createPersistor(persistKey, references);\n  const persistMiddleware = createPersistMiddleware(persistor, references);\n  const clearPersistance = createPersistenceClearer(persistKey, references);\n\n  const replaceState = nextState =>\n    references.internals.actionCreatorDict['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    references.internals = createStoreInternals({\n      disableImmer,\n      initialState: state,\n      injections,\n      model: modelDefinition,\n      reducerEnhancer,\n      references,\n    });\n  };\n\n  const mockActionsMiddleware = () => () => action => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(references),\n    reduxThunk,\n    ...middleware,\n    createListenerMiddleware(references),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    references.internals.reducer,\n    references.internals.defaultState,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    references.internals.computedState.isInReducer = false;\n  });\n\n  references.dispatch = store.dispatch;\n  references.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach(actionsKey => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(references.internals.actionCreators).forEach(key => {\n      store.dispatch[key] = references.internals.actionCreators[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = removeKey => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(references.internals.reducer);\n    replaceState(references.internals.defaultState);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    references,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `easy-peasy: The store model already contains a model definition for \"${key}\"`,\n        );\n        store.removeModel(key);\n      }\n      modelDefinition[key] = modelForKey;\n      rebindStore();\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => references.internals.actionCreators,\n    getListeners: () => references.internals.listenerActionCreators,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: clearPersistance,\n      flush: () => persistor.flush(),\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: newModel => {\n      modelDefinition = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: key => {\n      if (!modelDefinition[key]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `easy-peasy: The store model does not contain a model definition for \"${key}\"`,\n          );\n        }\n        return;\n      }\n      delete modelDefinition[key];\n      rebindStore(key);\n    },\n  });\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext, useMemo } from 'react';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport createStore from './create-store';\n\nexport default function createContextStore(model, config) {\n  const StoreContext = createContext();\n\n  function Provider({ children, initialData }) {\n    const store = useMemo(\n      () =>\n        createStore(\n          typeof model === 'function' ? model(initialData) : model,\n          config,\n        ),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","import { useMemo, useState, useRef, useEffect } from 'react';\nimport createStore from './create-store';\n\n/**\n * Some good references on the topic of reinitialisation:\n * - https://github.com/facebook/react/issues/14830\n */\n\nexport default function createComponentStore(model, config) {\n  return function useLocalStore(initialData) {\n    const store = useMemo(\n      () =>\n        createStore(\n          typeof model === 'function' ? model(initialData) : model,\n          config,\n        ),\n      [],\n    );\n    const previousStateRef = useRef(store.getState());\n    const [currentState, setCurrentState] = useState(() => store.getState());\n    useEffect(() => {\n      return store.subscribe(() => {\n        const nextState = store.getState();\n        if (previousStateRef.current !== nextState) {\n          previousStateRef.current = nextState;\n          setCurrentState(nextState);\n        }\n      });\n    }, [store]);\n    return [currentState, store.getActions()];\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport default function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n","import React from 'react';\nimport StoreContext from './context';\n\nexport default function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","import { setAutoFreeze } from 'immer-peasy';\nimport {\n  createTypedHooks,\n  useStoreActions,\n  useStoreDispatch,\n  useStoreState,\n  useStoreRehydrated,\n  useStore,\n} from './hooks';\nimport createStore from './create-store';\nimport createContextStore from './create-context-store';\nimport createComponentStore from './create-component-store';\nimport createTransform from './create-transform';\nimport StoreProvider from './provider';\nimport {\n  action,\n  actionOn,\n  computed,\n  debug,\n  memo,\n  persist,\n  reducer,\n  thunk,\n  thunkOn,\n} from './helpers';\n\n/**\n * The auto freeze feature of immer doesn't seem to work in our testing. We have\n * explicitly disabled it to avoid perf issues.\n */\nsetAutoFreeze(false);\n\nexport {\n  action,\n  actionOn,\n  computed,\n  createComponentStore,\n  createContextStore,\n  createStore,\n  createTransform,\n  createTypedHooks,\n  debug,\n  memo,\n  persist,\n  reducer,\n  StoreProvider,\n  thunk,\n  thunkOn,\n  useStoreActions,\n  useStoreDispatch,\n  useStoreState,\n  useStoreRehydrated,\n  useStore,\n};\n"]},"metadata":{},"sourceType":"module"}